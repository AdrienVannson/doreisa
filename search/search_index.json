{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Doreisa","text":"<p>Welcome to the documentation of Doreisa!</p>"},{"location":"analytics/","title":"Analytics","text":""},{"location":"analytics/#simple-example","title":"Simple example","text":"<pre><code>from doreisa.head_node import init\nfrom doreisa.window_api import ArrayDefinition, run_simulation\n\ninit()\n\ndef simulation_callback(array: da.Array, timestep: int):\n    x = array.sum().compute()\n    print(\"Sum:\", x)\n\nrun_simulation(\n    simulation_callback,\n    [ArrayDefinition(\"array\")],\n)\n</code></pre>"},{"location":"analytics/#several-arrays","title":"Several arrays","text":"<pre><code>from doreisa.head_node import init\nfrom doreisa.window_api import ArrayDefinition, run_simulation\n\ninit()\n\ndef simulation_callback(a: da.Array, b: da.Array, timestep: int):\n    r = (a - b).mean().compute()\n\nrun_simulation(\n    simulation_callback,\n    [ArrayDefinition(\"a\"), ArrayDefinition(\"b\")]\n)\n</code></pre>"},{"location":"analytics/#sliding-window","title":"Sliding window","text":"<p>If the analysis requires access to several iterations (for example, to compute time derivative), it is possible to use the <code>window_size</code> parameter.</p> <pre><code>from doreisa.head_node import init\nfrom doreisa.window_api import ArrayDefinition, run_simulation\n\ninit()\n\ndef simulation_callback(array: list[da.Array], timestep: int):\n    if len(arrays) &lt; 2:  # For the first iteration\n        return\n\n    current_array = array[1]\n    previous_array = array[0]\n\n    ...\n\nrun_simulation(\n    simulation_callback,\n    [\n        ArrayDefinition(\"array\", window_size=2),  # Enable sliding window\n    ],\n)\n</code></pre>"},{"location":"analytics/#dask-persist","title":"Dask persist","text":"<p>Dask's <code>persist</code> is supported:</p> <pre><code>from doreisa.head_node import init\nfrom doreisa.window_api import ArrayDefinition, run_simulation\n\ninit()\n\ndef simulation_callback(array: da.Array, timestep: int):\n    x = array.sum().persist()\n\n    # x is still a Dask array, but the sum is being computed in the background\n    assert isinstance(x, da.Array)\n\n    x_final = x.compute()\n    assert x_final == 10 * timestep\n\nrun_simulation(\n    simulation_callback,\n    [ArrayDefinition(\"array\")],\n    max_iterations=NB_ITERATIONS,\n)\n</code></pre>"},{"location":"analytics/#preprocessing-callbacks","title":"Preprocessing callbacks","text":"<p>A preprocessing callback is a function that is applied on each chunk of data. The function is executed locally, on the machine where the data is produced as soon as it is available.</p> <pre><code>from doreisa.head_node import init\nfrom doreisa.window_api import ArrayDefinition, run_simulation\n\ninit()\n\ndef simulation_callback(array: da.Array, timestep: int):\n    ...\n\nrun_simulation(\n    simulation_callback,\n    [ArrayDefinition(\"array\", preprocess=lambda chunk: 10 * chunk)],\n)\n</code></pre>"},{"location":"analytics/#improving-performance-prepare-an-iteration","title":"Improving performance: prepare an iteration","text":"<p>It is possible to define a callback that will be executed a bit before the data is ready. The return value of this callback will be passed as an argument to the actual simulation callback.</p> <p>This is particularly useful when combined with Dask's persist API: since the preparation callback is executed before the data is available, and since several preparation callbacks can be executed in parallel in different Ray workers, it makes it possible to hide the time taken to build the task graph, sent it to the workers, etc to avoid slowing down the simulation.</p> <p>In most situations, this is negligible, but it can start to matter with simulations running on hundreds of nodes, with task graphs composed of thousands of tasks.</p> <pre><code>from doreisa.head_node import init\nfrom doreisa.window_api import ArrayDefinition, run_simulation\n\ninit()\n\ndef prepare_iteration(array: da.Array, *, timestep: int) -&gt; da.Array:\n    # We can't use compute here since the data is not available yet\n    return array.sum().persist()\n\ndef simulation_callback(array: da.Array, *, timestep: int, preparation_result: da.Array):\n    print(preparation_result.compute())\n\nrun_simulation(\n    simulation_callback,\n    [ArrayDefinition(\"array\")],\n    max_iterations=NB_ITERATIONS,\n    prepare_iteration=prepare_iteration,\n    preparation_advance=10,\n)\n</code></pre>"}]}